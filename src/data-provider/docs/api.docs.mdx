# data-provider API

`createProvider` and `createSafeProvider` wrap async functions in a chainable, mockable, type-safe API.

→ [Usage Guide](usage.docs.mdx)

```ts
import { createProvider, createSafeProvider } from 'data-provider/data-provider';
```

---

## `createProvider(fn)`

Wraps an async function and returns a chainable callable. Errors propagate normally (throws).

```ts
const provider = createProvider(async (id: string) => fetchUser(id));

const user = await provider('123');
```

**Type parameters**

- `Fn` — the async function being wrapped; must return `Promise<T>`

**Returns** — a function with the same signature as `fn`, extended with `.andThen`, `.andCatch`, `.andFinally`, `.andMock`

---

## `createSafeProvider(fn, errorTypes?)`

Same as `createProvider` but wraps the result in a `[error, data]` tuple. Never throws.

```ts
const provider = createSafeProvider(async (id: string) => fetchUser(id));

const [error, user] = await provider('123');
```

**Parameters**

| Parameter | Type | Description |
|-----------|------|-------------|
| `fn` | `(...args) => Promise<T>` | The async function to wrap |
| `errorTypes` | `readonly ErrorConstructor[] \| undefined` | Optional — narrows the error type. Use `as const`. |

```ts
class NetworkError extends Error {}
class ValidationError extends Error {}

const provider = createSafeProvider(fetchUser, [NetworkError, ValidationError] as const);

const [error, user] = await provider('123');
// error: NetworkError | ValidationError | null
```

---

## Chainable Methods

All methods return the provider itself, enabling fluent chaining. Define the chain once at module level — it applies on every call.

### `.andThen(fn)`

Transforms the resolved value. The return type of `fn` becomes the new result type.

```ts
const provider = createSafeProvider(fetchUser)
  .andThen((user) => ({
    ...user,
    fullName: `${user.firstName} ${user.lastName}`,
  }));

const [error, user] = await provider('123');
// user.fullName is available and typed
```

### `.andCatch(fn)`

Handles errors. Return a fallback value to recover, or rethrow to propagate.

```ts
const provider = createProvider(fetchUser)
  .andCatch((error) => {
    logger.error('fetchUser failed', error);
    throw error; // rethrow
  });
```

### `.andFinally(fn)`

Runs after resolution or rejection — useful for cleanup.

```ts
const provider = createProvider(fetchUser)
  .andFinally(() => setLoading(false));
```

### `.andMock(fn)`

Registers a mock implementation. The mock is used whenever `isMockEnabled()` returns `true` (automatically in test environments, controlled via `enableMock()` in development, never in production).

The mock function must match the signature of the original `fn`.

```ts
const provider = createSafeProvider(api.fetchUser)
  .andMock(mock.fetchUser);
```

---

## Chain Order

Recommended ordering for readability (execution order is the same regardless):

```ts
createSafeProvider(apiFn)
  .andMock(mockFn)
  .andThen(transform)
  .andCatch(handleError)
  .andFinally(cleanup)
```

---

## Type Safety

Types are fully inferred throughout the chain. No manual annotations needed.

```ts
const provider = createSafeProvider(async (id: number) => ({ id, name: 'Alice' }))
  .andThen((user) => user.name);

// Inferred: (...args: [number]) => Promise<[Error | null, string | null]>
```

Parameters are always preserved from the original function, including multiple arguments and `AbortSignal`:

```ts
const provider = createSafeProvider(
  async (id: string, signal?: AbortSignal) => fetchUser(id, signal)
);

const controller = new AbortController();
const [error, user] = await provider('123', controller.signal);
controller.abort();
```
