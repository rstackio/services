# data-provider Usage

## Recommended file structure

Keep each provider's concerns in three files:

```
feature/
  api.ts        ← real async function
  mock.ts       ← mock using delay()
  provider.ts   ← createProvider(api).andMock(mock).andThen(...)
```

---

## Example: `getUser`

**`api.ts`** — the real implementation

```ts
export const getUser = async (id: string, signal?: AbortSignal) => {
  const res = await fetch(`/api/users/${id}`, { signal });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json() as Promise<User>;
};
```

**`mock.ts`** — the mock implementation

```ts
import { delay } from 'data-provider/mock';

export const getUser = (id: string, signal?: AbortSignal) =>
  delay(
    () => ({ id, firstName: 'Test', lastName: 'User', role: 'admin' }),
    { signal, delayMs: 300 }
  );
```

**`provider.ts`** — assembled provider

```ts
import { createSafeProvider } from 'data-provider/data-provider';
import { Logger } from 'data-provider/logger';
import * as api from './api';
import * as mock from './mock';

const logger = new Logger({ prefix: 'getUser' });

export const getUser = createSafeProvider(api.getUser)
  .andMock(mock.getUser)
  .andThen((user) => ({
    ...user,
    fullName: `${user.firstName} ${user.lastName}`,
  }))
  .andCatch((error) => {
    if (error.name === 'AbortError') {
      logger.warn('Request was aborted');
    } else {
      logger.error('Request failed', error);
    }
    throw error;
  });
```

**Usage in a component or service**

```ts
import { getUser } from './provider';

const controller = new AbortController();

const [error, user] = await getUser('123', controller.signal);

if (error) {
  // handle error
} else {
  console.log(user.fullName); // typed and transformed
}

// Cancel in-flight request
controller.abort();
```

---

## With `createProvider` (throws on error)

```ts
import { createProvider } from 'data-provider/data-provider';

export const getUser = createProvider(api.getUser)
  .andMock(mock.getUser)
  .andThen(normalize)
  .andFinally(() => analytics.track('getUser'));

try {
  const user = await getUser('123');
} catch (error) {
  // handle
}
```

---

## Testing

Mocks activate automatically when `NODE_ENV === 'test'` — no setup, no `vi.mock`, no wiring. Any provider with `.andMock()` uses the mock implementation across your entire test suite.

### Zero-config: import and test

```ts
// user.test.ts
import { getUser } from './provider'; // uses mock.getUser automatically

it('returns a transformed user', async () => {
  const [error, user] = await getUser('1');

  expect(error).toBeNull();
  expect(user?.fullName).toBe('Test User'); // value defined in mock.ts
});
```

### Suite-level mock with different API behaviors

Export the provider without calling `.andMock()` at module level — then control the mock per test suite:

```ts
// provider.ts — no .andMock() here; mocks are set in tests
export const getUser = createSafeProvider(api.getUser)
  .andThen((user) => ({ ...user, fullName: `${user.firstName} ${user.lastName}` }));
```

```ts
// user.test.ts
import { getUser } from './provider';
import * as mock from './mock';

describe('getUser', () => {
  beforeAll(() => {
    getUser.andMock(mock.getUser); // apply default mock for the whole suite
  });

  it('returns a user', async () => {
    const [error, user] = await getUser('1');
    expect(user?.fullName).toBe('Test User');
  });

  it('surfaces API errors', async () => {
    getUser.andMock(() => Promise.reject(new Error('Internal server error')));

    const [error] = await getUser('1');

    expect(error?.message).toBe('Internal server error');
  });

  it('handles not found', async () => {
    getUser.andMock(() => Promise.reject(new NotFoundError('user not found')));

    const [error] = await getUser('1');

    expect(error).toBeInstanceOf(NotFoundError);
  });
});
```

`.andMock()` mutates the provider in place — swap it freely per test. No `vi.mock`, no module factory overhead, no extra setup.

---

## Narrowing error types

Use `as const` to tell TypeScript exactly which errors can occur:

```ts
class NetworkError extends Error { status: number }
class NotFoundError extends Error {}

export const getUser = createSafeProvider(
  api.getUser,
  [NetworkError, NotFoundError] as const
);

const [error, user] = await getUser('123');

if (error instanceof NotFoundError) {
  // redirect to 404
} else if (error instanceof NetworkError) {
  // show retry UI, error.status is typed
}
```
