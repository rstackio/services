# data-provider Usage

## Recommended file structure

This is a suggested structure — not enforced by the library. The pattern that works well in practice:

```
src/
└── modules/
    └── user/
        ├── models/
        │   └── user.model.ts           ← types and validation schema, API and UI models
        ├── services/
        │   └── logger.service.ts       ← module-scoped logger instance
        └── data-provider/
            ├── api.ts                  ← real async function
            ├── mock.ts                 ← mock using delay()
            ├── normalize.ts            ← pure function to transform API response to UI model
            ├── provider.ts             ← createSafeProvider(api).andMock(mock).andThen(normalize)
            └── index.ts                ← export * from './provider'
```

Consume anywhere in the module:

```ts
import * as Dp from './data-provider';

const [error, user] = await Dp.getUser(id);
```

---

## Example: `getUser`

**`api.ts`** — the real implementation

```ts
import ky from 'ky';
import { userApiSchema } from '../models/user.model';

export const getUser = (id: string, signal?: AbortSignal) =>
  ky.get(`/api/users/${id}`, { signal }).json(userApiSchema);
```

> `ky` can be extended to add runtime schema validation — keeping individual `api.ts` files clean while ensuring runtime types always match build-time types.

**`mock.ts`** — the mock implementation

```ts
import { delay } from '@rstackio/services/mock';

export const getUser = (id: string, signal?: AbortSignal) =>
  delay(
    () => ({ id, firstName: 'Test', lastName: 'User', role: 'admin' as const }),
    { signal, delayMs: 300 }
  );
```

**`services/logger.service.ts`** — module-scoped logger instance

```ts
import { Logger } from '@rstackio/services/logger';

export const logger = new Logger({ prefix: 'user' }); // pass name of module
```

**`normalize.ts`** — pure transform, easy to test in isolation

```ts
import type { UserApi, User } from './models/user.model';

export const normalize = (user: UserApi): User => ({
  ...user,
  fullName: `${user.firstName} ${user.lastName}`,
});
```

**`provider.ts`** — assembled provider

```ts
import { createSafeProvider } from '@rstackio/services/data-provider';
import * as api from './api';
import * as mock from './mock';
import { normalize } from './normalize';
import { logger } from '../services/logger.service';

export const getUser = createSafeProvider(api.getUser)
  .andMock(mock.getUser) // TypeScript enforces mock matches the exact signature of api.getUser
  .andThen(normalize)    // final type is inferred from normalize's return — callers get User, not UserApi
  .andCatch((error) => {
    if (error.name === 'AbortError') {
      logger.warn('Request was aborted');
    } else {
      logger.error('Request failed', error);
    }
    throw error;
  });
```

**Usage in a component or service**

```ts
import { getUser } from './provider';

const controller = new AbortController();

const [error, user] = await getUser('123', controller.signal);

if (error) {
  // handle error
} else {
  console.log(user.fullName); // typed and transformed
}

// Cancel in-flight request
controller.abort();
```

---

## With `createProvider` (throws on error)

```ts
import { createProvider } from '@rstackio/services/data-provider';

export const getUser = createProvider(api.getUser)
  .andMock(mock.getUser)
  .andThen(normalize)
  .andFinally(() => analytics.track('getUser'));

try {
  const user = await getUser('123');
} catch (error) {
  // handle
}
```

---

## Testing

Mocks activate automatically when `NODE_ENV === 'test'` — no setup, no `vi.mock`, no wiring. Any provider with `.andMock()` uses the mock implementation across your entire test suite.

### Zero-config: import and test

```ts
// user.test.ts
import { getUser } from './provider'; // uses mock.getUser automatically

it('returns a transformed user', async () => {
  const [error, user] = await getUser('1');

  expect(error).toBeNull();
  expect(user?.fullName).toBe('Test User'); // value defined in mock.ts
});
```

### Suite-level mock with different API behaviors

Export the provider without calling `.andMock()` at module level — then control the mock per test suite:

```ts
// provider.ts — no .andMock() here; mocks are set in tests
export const getUser = createSafeProvider(api.getUser)
  .andThen((user) => ({ ...user, fullName: `${user.firstName} ${user.lastName}` }));
```

```ts
// user.test.ts
import { getUser } from './provider';
import * as mock from './mock';

describe('getUser', () => {
  beforeAll(() => {
    getUser.andMock(mock.getUser); // apply default mock for the whole suite
  });

  it('returns a user', async () => {
    const [error, user] = await getUser('1');
    expect(user?.fullName).toBe('Test User');
  });

  it('surfaces API errors', async () => {
    getUser.andMock(() => Promise.reject(new Error('Internal server error')));

    const [error] = await getUser('1');

    expect(error?.message).toBe('Internal server error');
  });

  it('handles not found', async () => {
    getUser.andMock(() => Promise.reject(new NotFoundError('user not found')));

    const [error] = await getUser('1');

    expect(error).toBeInstanceOf(NotFoundError);
  });
});
```

`.andMock()` mutates the provider in place — swap it freely per test. No `vi.mock`, no module factory overhead, no extra setup.

---

## Narrowing error types

Use `as const` to tell TypeScript exactly which errors can occur:

```ts
class NetworkError extends Error { status: number }
class NotFoundError extends Error {}

export const getUser = createSafeProvider(
  api.getUser,
  [NetworkError, NotFoundError] as const
);

const [error, user] = await getUser('123');

if (error instanceof NotFoundError) {
  // redirect to 404
} else if (error instanceof NetworkError) {
  // show retry UI, error.status is typed
}
```
